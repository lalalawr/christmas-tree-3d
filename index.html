<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ„ åœ£è¯å¿«ä¹ | ä½ çš„ä¸“å±ç²’å­ç¥ç¦æ ‘</title>
    <!-- å¼•å…¥ Tailwind CSS ç”¨äºå¿«é€Ÿå¸ƒå±€ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- å¼•å…¥ Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Noto+Sans+SC:wght@300;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-glow: #ffcfdf;
            --accent-color: #ff4d6d;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: radial-gradient(circle at center, #1a1a2e 0%, #0f0f1b 100%);
            color: white;
            font-family: 'Noto Sans SC', sans-serif;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* é¡¶éƒ¨ UI å±‚ */
        .overlay-ui {
            position: relative;
            z-index: 10;
            pointer-events: none;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 2rem;
        }

        .pointer-events-auto {
            pointer-events: auto;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            /* æ·»åŠ è¿‡æ¸¡æ•ˆæœï¼Œè®©æ¶ˆå¤±æ›´å¹³æ»‘ */
            transition: opacity 2s ease, transform 2.5s ease, filter 2s ease;
        }

        .wish-text {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 2.5rem;
            text-shadow: 0 0 15px var(--primary-glow);
            text-align: center;
            transition: all 0.5s ease;
        }

        input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        /* ã€ä¿®æ”¹éƒ¨åˆ†ã€‘å®šä¹‰æ¶ˆå¤±çš„åŠ¨ç”»æ ·å¼ */
        .ui-fade-out {
            opacity: 0 !important;
            transform: translateY(-40px);
            filter: blur(15px);
            pointer-events: none !important;
        }
        
        /* æ‘„åƒå¤´é¢„è§ˆçª— */
        #video-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.3);
            z-index: 20;
            transform: scaleX(-1); /* é•œåƒæ˜¾ç¤º */
        }

        #gesture-hint {
            position: absolute;
            bottom: 150px;
            right: 20px;
            background: rgba(255, 77, 109, 0.8);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.8rem;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 20;
        }

        /* æŒ‰é’®åŠ¨ç”» */
        .btn-festive {
            background: linear-gradient(45deg, #ff4d6d, #ff8fa3);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .btn-festive:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 77, 109, 0.6);
        }

        /* æå…‰èƒŒæ™¯ */
        .aurora {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, transparent, rgba(0, 255, 128, 0.05), transparent);
            filter: blur(50px);
            z-index: 0;
            animation: drift 10s infinite alternate linear;
        }

        @keyframes drift {
            from { transform: translateY(-10%) rotate(0deg); }
            to { transform: translateY(10%) rotate(5deg); }
        }

        /* åŠ è½½åŠ¨ç”» */
        #loader {
            position: fixed;
            inset: 0;
            background: #0f0f1b;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
    </style>
</head>
<body>

    <div id="loader">
        <div class="text-4xl mb-4">ğŸ„</div>
        <div class="text-white text-xl animate-pulse">æ­£åœ¨ç‚¹äº®åœ£è¯æ£®æ—...</div>
    </div>

    <div class="aurora"></div>
    <div id="canvas-container"></div>

    <div class="overlay-ui">
        <!-- é¡¶éƒ¨ï¼šè¾“å…¥ä¸ç¥ç¦ -->
        <div class="w-full max-w-md pointer-events-auto">
            <!-- ã€ä¿®æ”¹éƒ¨åˆ†ã€‘å¢åŠ  ID æ–¹ä¾¿æ§åˆ¶ -->
            <div id="inputPanel" class="glass-panel text-center mb-6">
                <input type="text" id="nameInput" placeholder="è¾“å…¥ä½ çš„åå­—..." 
                       class="bg-transparent border-b-2 border-pink-300 text-center text-xl w-full focus:outline-none mb-4 py-2">
                <div id="wishDisplay" class="wish-text">
                    ğŸ„ Merry Christmas!
                </div>
            </div>
        </div>

        <!-- ä¸­é—´ï¼šæç¤ºä¿¡æ¯ -->
        <!-- ã€ä¿®æ”¹éƒ¨åˆ†ã€‘å¢åŠ  ID æ–¹ä¾¿åŒæ­¥éšé€€ -->
        <div id="tipPanel" class="text-center text-sm opacity-60 transition-opacity duration-1000">
            <p>âœ‹ ç»½æ”¾ | âœŠ èšåˆ | ğŸ‘‰ æŒ¥æ‰‹å˜è‰²</p>
            <p class="mt-2 text-xs">å»ºè®®åœ¨å…‰çº¿å……è¶³çš„ç¯å¢ƒä¸‹å¼€å¯æ‘„åƒå¤´ä½“éªŒ</p>
        </div>

        <!-- åº•éƒ¨ï¼šæ§åˆ¶ -->
        <div class="pointer-events-auto">
            <button id="startCamera" class="btn-festive px-8 py-3 rounded-full font-bold shadow-lg flex items-center gap-2">
                <span>ğŸ“¸</span> å¼€å¯äº¤äº’æ¨¡å¼
            </button>
        </div>
    </div>

    <!-- äº¤äº’åé¦ˆ -->
    <div id="gesture-hint">è¯†åˆ«ä¸­...</div>
    <div id="video-container">
        <video id="webcam" autoplay playsinline style="width: 100%; height: 100%; object-fit: cover;"></video>
    </div>

    <!-- ä¾èµ–åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        /**
         * 1. åœºæ™¯åˆå§‹åŒ– & åœ£è¯æ ‘æ„å»º
         */
        let scene, camera, renderer, particles, star;
        const particleCount = 6000;
        const colors = [0xff4d6d, 0xffcfdf, 0xffd700, 0x00ff88, 0x00d2ff, 0xbd93f9];
        let currentThemeIndex = 0;
        let expansionFactor = 1.0; // æ‰‹åŠ¿æ§åˆ¶ç¼©æ”¾å› å­

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            createTree();
            createStar();
            createSnow();

            animate();
            document.getElementById('loader').style.display = 'none';
        }

        function createTree() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const pColors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            for (let i = 0; i < particleCount; i++) {
                const r = Math.pow(Math.random(), 1.5) * 2;
                const theta = Math.random() * 2 * Math.PI;
                const h = Math.random() * 4 - 2; 
                
                const currentRadius = r * (1 - (h + 2) / 4.5);
                
                positions[i * 3] = Math.cos(theta) * currentRadius;
                positions[i * 3 + 1] = h;
                positions[i * 3 + 2] = Math.sin(theta) * currentRadius;

                const color = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);
                pColors[i * 3] = color.r;
                pColors[i * 3 + 1] = color.g;
                pColors[i * 3 + 2] = color.b;

                sizes[i] = Math.random() * 0.05 + 0.02;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(pColors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.04,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function createStar() {
            const geometry = new THREE.SphereGeometry(0.15, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: 0xffffaa });
            star = new THREE.Mesh(geometry, material);
            star.position.y = 2.1;
            scene.add(star);

            const spriteMaterial = new THREE.SpriteMaterial({
                map: createGlowTexture(),
                color: 0xffffaa,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(0.8, 0.8, 1);
            star.add(sprite);
        }

        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,200,0.5)');
            gradient.addColorStop(1, 'rgba(255,255,200,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        let snowflakes;
        function createSnow() {
            const snowGeo = new THREE.BufferGeometry();
            const snowPos = new Float32Array(1000 * 3);
            for(let i=0; i<3000; i++) {
                snowPos[i] = (Math.random() - 0.5) * 10;
            }
            snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
            const snowMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.02, transparent: true });
            snowflakes = new THREE.Points(snowGeo, snowMat);
            scene.add(snowflakes);
        }
        
        /**
         * ã€ä¿®æ”¹éƒ¨åˆ†ã€‘äº¤äº’é€»è¾‘ï¼šåå­—è¾“å…¥ä¸è‡ªåŠ¨æ¶ˆå¤±
         */
        const nameInput = document.getElementById('nameInput');
        const wishDisplay = document.getElementById('wishDisplay');
        const inputPanel = document.getElementById('inputPanel');
        const tipPanel = document.getElementById('tipPanel');

        // æ‰§è¡Œæ¶ˆå¤±åŠ¨ç”»çš„å‡½æ•°
        function fadeOutUI() {
            inputPanel.classList.add('ui-fade-out');
            tipPanel.classList.add('opacity-0'); // åŒæ—¶è®©ä¸­é—´æç¤ºå˜é€æ˜
        }

        nameInput.addEventListener('input', (e) => {
            const name = e.target.value.trim();
            if (name) {
                wishDisplay.innerText = `ğŸ„ Merry Christmas, ${name}ï¼æ„¿ä½ çš„ä¸–ç•Œæ°¸è¿œé—ªé—ªå‘å…‰ âœ¨`;
                wishDisplay.style.color = '#ff8fa3';
            } else {
                wishDisplay.innerText = `ğŸ„ Merry Christmas!`;
                wishDisplay.style.color = 'white';
            }
        });

        // ç›‘å¬å›è½¦é”®ï¼šæŒ‰å›è½¦å³è§†ä¸ºè¾“å…¥å®Œæˆ
        nameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                nameInput.blur(); // è§¦å‘å¤±å»ç„¦ç‚¹äº‹ä»¶
            }
        });

        // ç›‘å¬å¤±å»ç„¦ç‚¹ï¼šç”¨æˆ·ç‚¹å¼€åˆ«å¤„æˆ–æŒ‰å›è½¦åï¼Œ3ç§’å¯åŠ¨æ¶ˆå¤±å€’è®¡æ—¶
        nameInput.addEventListener('blur', () => {
            if (nameInput.value.trim()) {
                setTimeout(fadeOutUI, 3000); 
            }
        });
        
        /**
         * 3. æ ¸å¿ƒï¼šæ‰‹åŠ¿è¯†åˆ« (MediaPipe)
         */
        const videoElement = document.getElementById('webcam');
        const startBtn = document.getElementById('startCamera');
        const hint = document.getElementById('gesture-hint');

        async function initGesture() {
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults(onResults);

            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            camera.start();
        }

        let lastX = 0;
        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const indexFingerTip = landmarks[8];
                const wrist = landmarks[0];
                const distance = Math.sqrt(Math.pow(indexFingerTip.x - wrist.x, 2) + Math.pow(indexFingerTip.y - wrist.y, 2));

                if (distance > 0.4) {
                    expansionFactor = 2.5;
                    showHint("âœ‹ ç»½æ”¾ï¼šçµæ„Ÿè¿¸å‘ï¼");
                } else {
                    expansionFactor = 0.5;
                    showHint("âœŠ èšåˆï¼šæ¸©æš–å‡èš");
                }

                const currentX = indexFingerTip.x;
                if (Math.abs(currentX - lastX) > 0.15) {
                    changeTheme();
                    showHint("ğŸ‘‰ å˜è‰²ï¼šæ¢ä¸€ç§å¿ƒæƒ…");
                }
                lastX = currentX;

                hint.style.opacity = 1;
            } else {
                expansionFactor = 1.0;
                hint.style.opacity = 0;
            }
        }

        function showHint(text) {
            hint.innerText = text;
            hint.style.opacity = 1;
        }

        function changeTheme() {
            currentThemeIndex = (currentThemeIndex + 1) % colors.length;
            const colorAttr = particles.geometry.attributes.color;
            const targetColor = new THREE.Color(colors[currentThemeIndex]);
            
            for (let i = 0; i < particleCount; i++) {
                if(Math.random() > 0.3) {
                    colorAttr.array[i * 3] = targetColor.r;
                    colorAttr.array[i * 3 + 1] = targetColor.g;
                    colorAttr.array[i * 3 + 2] = targetColor.b;
                }
            }
            colorAttr.needsUpdate = true;
        }

        startBtn.addEventListener('click', () => {
            initGesture();
            startBtn.innerText = "âœ¨ äº¤äº’å·²å¼€å¯";
            startBtn.disabled = true;
            startBtn.style.opacity = "0.5";
        });

        /**
         * 4. åŠ¨ç”»å¾ªç¯
         */
        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            particles.rotation.y += 0.005;
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                const ix = i * 3;
                particles.geometry.attributes.color.array[ix] += Math.sin(time + i) * 0.001;
            }
            particles.scale.lerp(new THREE.Vector3(expansionFactor, expansionFactor, expansionFactor), 0.1);
            star.scale.setScalar(1 + Math.sin(time * 3) * 0.1);
            snowflakes.position.y -= 0.01;
            if (snowflakes.position.y < -5) snowflakes.position.y = 5;
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.onload = initThree;
    </script>
</body>
</html>
